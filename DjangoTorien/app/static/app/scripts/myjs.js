'use strict';   /**  * Object.assign() polyfill  */ Object.assign || Object.defineProperty(Object, "assign", { enumerable: !1, configurable: !0, writable: !0, value: function (a, b) { "use strict"; if (void 0 === a || null === a) error("Cannot convert first argument to object"); for (var c = Object(a), d = 1; d < arguments.length; d++) { var e = arguments[d]; if (void 0 !== e && null !== e) for (var f = Object.keys(Object(e)), g = 0, h = f.length; g < h; g++) { var i = f[g], j = Object.getOwnPropertyDescriptor(e, i); void 0 !== j && j.enumerable && (c[i] = e[i]) } } return c } });  /**  * CustomEvent() polyfill  */ !function () { if ("function" == typeof window.CustomEvent) return; function t(t, e) { e = e || { bubbles: !1, cancelable: !1, detail: void 0 }; var n = document.createEvent("CustomEvent"); return n.initCustomEvent(t, e.bubbles, e.cancelable, e.detail), n } t.prototype = window.Event.prototype, window.CustomEvent = t }();   /**  * Функция определения события swipe на элементе.  * @param {Object} el - элемент DOM.  * @param {Object} settings - объект с предварительными настройками.  */ var swipe = function (e, settings) {      // настройки по умолчанию     var settings = Object.assign({}, {         minDist: 60,  // минимальная дистанция, которую должен пройти указатель, чтобы жест считался как свайп (px)         maxDist: 120, // максимальная дистанция, не превышая которую может пройти указатель, чтобы жест считался как свайп (px)         maxTime: 700, // максимальное время, за которое должен быть совершен свайп (ms)         minTime: 50   // минимальное время, за которое должен быть совершен свайп (ms)     }, settings);      // коррекция времени при ошибочных значениях     if (settings.maxTime < settings.minTime) settings.maxTime = settings.minTime + 500;     if (settings.maxTime < 100 || settings.minTime < 50) {         settings.maxTime = 700;         settings.minTime = 50;     }      var el = e,       // отслеживаемый элемент         dir,                  // направление свайпа (horizontal, vertical)         swipeType,            // тип свайпа (up, down, left, right)         dist,                 // дистанция, пройденная указателем         isMouse = false,      // поддержка мыши (не используется для тач-событий)         isMouseDown = false,  // указание на активное нажатие мыши (не используется для тач-событий)         startX = 0,           // начало координат по оси X (pageX)         distX = 0,            // дистанция, пройденная указателем по оси X         startY = 0,           // начало координат по оси Y (pageY)         distY = 0,            // дистанция, пройденная указателем по оси Y         startTime = 0,        // время начала касания         support = {           // поддерживаемые браузером типы событий             pointer: !!("PointerEvent" in window || ("msPointerEnabled" in window.navigator)),             touch: !!(typeof window.orientation !== "undefined" || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || "ontouchstart" in window || navigator.msMaxTouchPoints || "maxTouchPoints" in window.navigator > 1 || "msMaxTouchPoints" in window.navigator > 1)         };      /**      * Опредление доступных в браузере событий: pointer, touch и mouse.      * @returns {Object} - возвращает объект с доступными событиями.      */     var getSupportedEvents = function () {         switch (true) {             case support.pointer:                 events = {                     type: "pointer",                     start: "PointerDown",                     move: "PointerMove",                     end: "PointerUp",                     cancel: "PointerCancel",                     leave: "PointerLeave"                 };                 // добавление префиксов для IE10                 var ie10 = (window.navigator.msPointerEnabled && Function('/*@cc_on return document.documentMode===10@*/')());                 for (var value in events) {                     if (value === "type") continue;                     events[value] = (ie10) ? "MS" + events[value] : events[value].toLowerCase();                 }                 break;             case support.touch:                 events = {                     type: "touch",                     start: "touchstart",                     move: "touchmove",                     end: "touchend",                     cancel: "touchcancel"                 };                 break;             default:                 events = {                     type: "mouse",                     start: "mousedown",                     move: "mousemove",                     end: "mouseup",                     leave: "mouseleave"                 };                 break;         }         return events;     };       /**      * Объединение событий mouse/pointer и touch.      * @param e {Event} - принимает в качестве аргумента событие.      * @returns {TouchList|Event} - возвращает либо TouchList, либо оставляет событие без изменения.      */     var eventsUnify = function (e) {         return e.changedTouches ? e.changedTouches[0] : e;     };       /**      * Обрабочик начала касания указателем.      * @param e {Event} - получает событие.      */     var checkStart = function (e) {         var event = eventsUnify(e);         if (support.touch && typeof e.touches !== "undefined" && e.touches.length !== 1) return; // игнорирование касания несколькими пальцами         dir = "none";         swipeType = "none";         dist = 0;         startX = event.pageX;         startY = event.pageY;         startTime = new Date().getTime();         if (isMouse) isMouseDown = true; // поддержка мыши         e.preventDefault();     };      /**      * Обработчик движения указателя.      * @param e {Event} - получает событие.      */     var checkMove = function (e) {         if (isMouse && !isMouseDown) return; // выход из функции, если мышь перестала быть активна во время движения         var event = eventsUnify(e);         distX = event.pageX - startX;         distY = event.pageY - startY;         if (Math.abs(distX) > Math.abs(distY)) dir = (distX < 0) ? "left" : "right";         else dir = (distY < 0) ? "up" : "down";         e.preventDefault();     };      /**      * Обработчик окончания касания указателем.      * @param e {Event} - получает событие.      */     var checkEnd = function (e) {         if (isMouse && !isMouseDown) { // выход из функции и сброс проверки нажатия мыши             mouseDown = false;             return;         }         var endTime = new Date().getTime();         var time = endTime - startTime;         if (time >= settings.minTime && time <= settings.maxTime) { // проверка времени жеста             if (Math.abs(distX) >= settings.minDist && Math.abs(distY) <= settings.maxDist) {                 swipeType = dir; // опредление типа свайпа как "left" или "right"             } else if (Math.abs(distY) >= settings.minDist && Math.abs(distX) <= settings.maxDist) {                 swipeType = dir; // опредление типа свайпа как "top" или "down"             }         }         dist = (dir === "left" || dir === "right") ? Math.abs(distX) : Math.abs(distY); // опредление пройденной указателем дистанции          // генерация кастомного события swipe         if (swipeType !== "none" && dist >= settings.minDist) {             var swipeEvent = new CustomEvent("swipe", {                 bubbles: true,                 cancelable: true,                 detail: {                     full: e, // полное событие Event                     dir: swipeType, // направление свайпа                     dist: dist, // дистанция свайпа                     time: time // время, потраченное на свайп                 }             });             el.dispatchEvent(swipeEvent);         }         e.preventDefault();     };      // добавление поддерживаемых событий     var events = getSupportedEvents();      // проверка наличия мыши     if ((support.pointer && !support.touch) || events.type === "mouse") isMouse = true;      // добавление обработчиков на элемент     el.addEventListener(events.start, checkStart);     el.addEventListener(events.move, checkMove);     el.addEventListener(events.end, checkEnd);  };  $(document).ready(function () {     var pages = 6,         scrolling = false,         hei = document.getElementById('parallax').offsetHeight,         currentPage = 1;      /*****************************     ***** NAVIGATE FUNCTIONS *****     *****************************/     function manageClasses() {         scrolling = true;         setTimeout(function () {             scrolling = false;         }, 600);     }     function navigateUp() {         if (currentPage > 1) {             currentPage--;             manageClasses();             var t = $("#group" + currentPage).offset().top             $('.parallax').animate({                 scrollTop: hei * (currentPage - 1)             }, 600);         }     }      function navigateDown() {         if (currentPage < pages) {             manageClasses();             var t = $("#group" + currentPage).offset().top             $('.parallax').animate({                 scrollTop: hei * currentPage             }, 600);             currentPage++;         }     }      /*********************     ***** MOUSEWHEEL *****     *********************/     //$(document).on("mousewheel DOMMouseScroll", function (e) {     //    if (!scrolling) {     //        if (e.originalEvent.wheelDelta > 0 || e.originalEvent.detail < 0) {     //            navigateUp();     //        } else {     //            navigateDown();     //        }     //    }     //});      var touch_position; // Координата нажатия      function MyFunc(e) {         if (!scrolling) {             //if (e.type == 'swipe') {             //    if (e.detail.dir == "up") {             //        navigateDown();             //    } else if (e.detail.dir == "down") {             //        navigateUp();             //    }             //} else             if (e.type == 'mousewheel') {                 if (e.wheelDelta > 0 || e.detail < 0) {                     navigateUp();                 } else {                     navigateDown();                 }             } else if (e.type == 'touchstart') {                 console.log("touchstart");                 // При начальном нажатии получить координаты                 touch_position = e.touches[0].pageY;             } else if (e.type == 'touchmove') {                 console.log("touchmove");                 e.preventDefault();                 e.stopPropagation();                 return false;             } else if (e.type == 'touchend') {                 console.log("touchend");                 // При движении нажатия отслеживать направление движения                 var tmp_move = touch_position - e.changedTouches[0].pageY;                 // Сдвиг достаточный?                 if (Math.abs(tmp_move) < 50) {                     //e.preventDefault();                     //e.stopPropagation();                     return false;                 }                 if (tmp_move < 0) {                     console.log("Листаем вверх");                     navigateUp();                     // Листаем вправо                 }                 else {                     console.log("Листаем вниз");                     navigateDown();                     // Листаем влево                 }                 touch_position = tmp_move;             }         }     }      //var el = document.getElementById('parallax');     var el = document;     //swipe(el);     //el.addEventListener("swipe", function (e) {     //    MyFunc(e);     //});     el.addEventListener("mousewheel", function (e) {         MyFunc(e);     });     el.addEventListener("DOMMouseScroll", function (e) {         MyFunc(e);     });     el.addEventListener("touchstart", function (e) {         MyFunc(e);     });     el.addEventListener("touchmove", function (e) {         MyFunc(e);     });     el.addEventListener("touchend", function (e) {         MyFunc(e);     }); }); 